////////////////////////////////////////////////////////////////////////////////////////////////////
// NoesisGUI - http://www.noesisengine.com
// Copyright (c) 2013 Noesis Technologies S.L. All Rights Reserved.
////////////////////////////////////////////////////////////////////////////////////////////////////


#include <NsMath/Utils.h>


namespace Noesis
{

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
T Length(const Vector2<T>& v)
{
    return Sqrt(v.x * v.x + v.y * v.y);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
T LengthSquared(const Vector2<T>& v)
{
    return v.x * v.x + v.y * v.y;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
Vector2<T> Normalize(const Vector2<T>& v)
{
    NS_ASSERT(Length(v) > std::numeric_limits<T>::epsilon());
    T length = Length(v);
    return Vector2<T>(v.x / length, v.y / length);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
Vector2<T> PerpendicularCCW(const Vector2<T>& v)
{
    return Vector2<T>(-v.y, v.x);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
Vector2<T> PerpendicularCW(const Vector2<T>& v)
{
    return Vector2<T>(v.y, -v.x);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
Vector2<T> Perpendicular(const Vector2<T>& v, bool cw)
{
    if (cw)
    {
        return Vector2<T>(v.y, -v.x);
    }
    else
    {
        return Vector2<T>(-v.y, v.x);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector2<T> operator+(const Vector2<T>& v)
{
    return v;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector2<T> operator-(const Vector2<T>& v)
{
    return Vector2<T>(-v.x, -v.y);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector2<T> operator+(const Vector2<T>& v0, const Vector2<T>& v1)
{
    return Vector2<T>(v0.x + v1.x, v0.y + v1.y);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector2<T> operator-(const Vector2<T>& v0, const Vector2<T>& v1)
{
    return Vector2<T>(v0.x - v1.x, v0.y - v1.y);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector2<T> operator*(const Vector2<T>& v, T f)
{
    return Vector2<T>(v.x * f, v.y * f);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector2<T> operator*(T f, const Vector2<T>& v)
{
    return Vector2<T>(v.x * f, v.y * f);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector2<T> operator/(const Vector2<T>& v, T f)
{
    return Vector2<T>(v.x / f, v.y / f);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
T Dot(const Vector2<T>& v0, const Vector2<T>& v1)
{
    return v0.x * v1.x + v0.y * v1.y;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
T PerpDot(const Vector2<T>& v0, const Vector2<T>& v1)
{
    return v0.x * v1.y - v0.y * v1.x;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector2<T> Lerp(const Vector2<T>& v0, const Vector2<T>& v1, float t)
{
    return Vector2<T>(Lerp(v0.x, v1.x, t), Lerp(v0.y, v1.y, t));
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
T SignedAngle(const Vector2<T>& v0, const Vector2<T>& v1)
{
    return ATan2(PerpDot(v0, v1), Dot(v0, v1));
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
T Length(const Vector3<T>& v)
{
    return Sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
T LengthSquared(const Vector3<T>& v)
{
    return v.x * v.x + v.y * v.y + v.z * v.z;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
Vector3<T> Normalize(const Vector3<T>& v)
{
    NS_ASSERT(Length(v) > std::numeric_limits<T>::epsilon());
    T lenght = Length(v);
    return Vector3<T>(v.x / lenght, v.y / lenght, v.z / lenght);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
Vector2<T> Project(const Vector3<T>& v)
{
    NS_ASSERT(v.z > std::numeric_limits<T>::epsilon());
    return Vector2<T>(v.x / v.z, v.y / v.z);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector3<T> operator+(const Vector3<T>& v)
{
    return v;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector3<T> operator-(const Vector3<T>& v)
{
    return Vector3<T>(-v.x, -v.y, -v.z);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector3<T> operator+(const Vector3<T>& v0, const Vector3<T>& v1)
{
    return Vector3<T>(v0.x + v1.x, v0.y + v1.y, v0.z + v1.z);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector3<T> operator-(const Vector3<T>& v0, const Vector3<T>& v1)
{
    return Vector3<T>(v0.x - v1.x, v0.y - v1.y, v0.z - v1.z);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector3<T> operator*(const Vector3<T>& v, T f)
{
    return Vector3<T>(v.x * f, v.y * f, v.z * f);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector3<T> operator*(T f, const Vector3<T>& v)
{
    return Vector3<T>(v.x * f, v.y * f, v.z * f);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector3<T> operator/(const Vector3<T>& v, T f)
{
    return Vector3<T>(v.x / f, v.y / f, v.z / f);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
T Dot(const Vector3<T>& v0, const Vector3<T>& v1)
{
    return v0.x * v1.x + v0.y * v1.y + v0.z * v1.z;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
Vector3<T> Cross(const Vector3<T>& v0, const Vector3<T>& v1)
{
    return  Vector3<T>(v0.y * v1.z - v0.z * v1.y, v0.z * v1.x - v0.x * v1.z,
        v0.x * v1.y - v0.y * v1.x);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
T Length(const Vector4<T>& v)
{
    return Sqrt(v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
T LengthSquared(const Vector4<T>& v)
{
    return v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
Vector4<T> Normalize(const Vector4<T>& v)
{
    NS_ASSERT(Length(v) > std::numeric_limits<T>::epsilon());
    T length = Length(v);
    return Vector4<T>(v.x / length, v.y / length, v.z / length, v.w / length);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
Vector3<T> Project(const Vector4<T>& v)
{
    NS_ASSERT(v.w > std::numeric_limits<T>::epsilon());
    return Vector3<T>(v.x / v.w, v.y / v.w, v.z / v.w);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector4<T> operator+(const Vector4<T>& v)
{
    return v;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector4<T> operator-(const Vector4<T>& v)
{
    return Vector4<T>(-v.x, -v.y, -v.z, -v.w);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector4<T> operator+(const Vector4<T>& v0, const Vector4<T>& v1)
{
    return Vector4<T>(v0.x + v1.x, v0.y + v1.y, v0.z + v1.z, v0.w + v1.w);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector4<T> operator-(const Vector4<T>& v0, const Vector4<T>& v1)
{
    return Vector4<T>(v0.x - v1.x, v0.y - v1.y, v0.z - v1.z, v0.w - v1.w);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector4<T> operator*(const Vector4<T>& v, T f)
{
    return Vector4<T>(v.x * f, v.y * f, v.z * f, v.w * f);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector4<T> operator*(T f, const Vector4<T>& v)
{
    return Vector4<T>(v.x * f, v.y * f, v.z * f, v.w * f);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
const Vector4<T> operator/(const Vector4<T>& v, T f)
{
    return Vector4<T>(v.x / f, v.y / f, v.z / f, v.w / f);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
T Dot(const Vector4<T>& v0, const Vector4<T>& v1)
{
    return v0.x * v1.x + v0.y * v1.y + v0.z * v1.z + v0.w * v1.w;
}

}
