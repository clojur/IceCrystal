////////////////////////////////////////////////////////////////////////////////////////////////////
// NoesisGUI - http://www.noesisengine.com
// Copyright (c) 2013 Noesis Technologies S.L. All Rights Reserved.
////////////////////////////////////////////////////////////////////////////////////////////////////


#include <NsCore/Error.h>

#include <math.h>
#include <stdlib.h>


namespace Noesis
{

////////////////////////////////////////////////////////////////////////////////////////////////////
inline bool IsPow2(uint32_t x)
{
    return x == 0 ? false: ((x & (x - 1)) == 0);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline uint32_t NearestPow2(uint32_t x)
{
    int32_t next = NextPow2(x);
    int32_t prev = PrevPow2(x);

    if (x - prev <= next - x)
    {
        return prev;
    }
    else
    {
        return next;
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline uint32_t NextPow2(uint32_t x)
{
    /// Hacker's Delight (pg 48)
    x = x - 1;
    x = x | (x >> 1);
    x = x | (x >> 2);
    x = x | (x >> 4);
    x = x | (x >> 8);
    x = x | (x >> 16);

    return x + 1;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline uint32_t PrevPow2(uint32_t x)
{
    /// Hacker's Delight (pg 47)
    x = x | (x >> 1);
    x = x | (x >> 2);
    x = x | (x >> 4);
    x = x | (x >> 8);
    x = x | (x >> 16);

    return x - (x >> 1);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline bool IsOne(float val, float epsilon)
{
    return fabsf(val - 1.0f) < epsilon;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline bool IsZero(float val, float epsilon)
{
    return fabsf(val) < epsilon;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline bool AreClose(float a, float b, float epsilon)
{
    return fabsf(a - b) < epsilon;
}

#define GET_FLOAT_WORD(ix, x) union F2I { float f; uint32_t i; } f2i = { x }; ix = f2i.i;

////////////////////////////////////////////////////////////////////////////////////////////////////
inline bool IsNaN(float val)
{
    // std::isnan and similars cannot be used here because they can be optimized out by the
    // compiler when FAST_MATH is enabled. Even if the code is compiled with FAST_MATH we need
    // to use NAN floats because they are used internally by WPF as unitialized floats

    uint32_t i;
    GET_FLOAT_WORD(i, val);
    i &= 0x7fffffff;
    i = 0x7f800000 - i;
    uint32_t r = ((uint32_t)(i)) >> 31;
    return r == 1;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline bool IsNaN(double x)
{
    union { double f; uint64_t u; } ieee754 = { x };
    return ((uint32_t)(ieee754.u >> 32) & 0x7fffffff) + ((uint32_t)ieee754.u != 0) > 0x7ff00000;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline bool IsFinite(float val)
{
    uint32_t i;
    GET_FLOAT_WORD(i, val);
    uint32_t r = (uint32_t)((i & 0x7f800000) - 0x7f800000) >> 31;
    return r == 1;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline bool IsPositiveInfinity(float val)
{
    int32_t i, t;
    GET_FLOAT_WORD(i, val);
    t = i & 0x7fffffff;
    t ^= 0x7f800000;
    t |= -t;
    int32_t r = ~(t >> 31) & (i >> 30);
    return r == 1;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline bool IsNegativeInfinity(float val)
{
    int32_t i, t;
    GET_FLOAT_WORD(i, val);
    t = i & 0x7fffffff;
    t ^= 0x7f800000;
    t |= -t;
    int32_t r = ~(t >> 31) & (i >> 30);
    return r == -1;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline bool IsInfinity(float val)
{
    int32_t i, t;
    GET_FLOAT_WORD(i, val);
    t = i & 0x7fffffff;
    t ^= 0x7f800000;
    t |= -t;
    int32_t r = ~(t >> 31) & (i >> 30);
    return r == 1 || r == -1;
}

#undef GET_FLOAT_WORD

////////////////////////////////////////////////////////////////////////////////////////////////////
inline int Trunc(float val)
{
    return static_cast<int>(val);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline int Round(float val)
{
    // In SSE4.1 _mm_round_ss could be used
    return static_cast<int>(val > 0.0f ? val + 0.5f : val - 0.5f);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline float Floor(float val)
{
    // In SSE4.1 _mm_round_ss could be used
    return floorf(val);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline float Ceil(float val)
{
    // In SSE4.1 _mm_round_ss could be used
    return ceilf(val);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> const T& Max(const T& a, const T& b)
{
    return a < b ? b : a;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> const T& Min(const T& a, const T& b)
{
    return b < a ? b : a;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> T Clip(T val, T min, T max)
{
    NS_ASSERT(min <= max);
    return Min(Max(min, val), max);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
float Lerp(float x, float y, float t)
{
    return x + t * (y - x);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline float Pow(float base, float exponent)
{
    return powf(base, exponent);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline float Sqr(float v)
{
    return v * v;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline float Sqrt(float v)
{
    return sqrtf(v);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline float Sin(float v)
{
    return sinf(v);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline float Cos(float v)
{
    return cosf(v);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline float ASin(float v)
{
    return asinf(v);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline float ACos(float v)
{
    return acosf(v);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline float Tan(float v)
{
    return tanf(v);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline float ATan2(float v0, float v1)
{
    return atan2f(v0, v1);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline int32_t Abs(int32_t v)
{
    return abs(v);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
inline float Abs(float v)
{
    return fabsf(v);
}

}
